(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{628:function(v,_,t){"use strict";t.r(_);var r=t(2),s=Object(r.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("blockquote",[t("p",[v._v("贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。贪心算法简洁且高效，在许多实际问题中有着广泛的应用。")]),v._v(" "),t("p",[v._v("贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理不同。")]),v._v(" "),t("ul",[t("li",[v._v("动态规划会根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解。")]),v._v(" "),t("li",[v._v("贪心算法不会考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决。")])])]),v._v(" "),t("h3",{attrs:{id:"贪心算法特性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法特性"}},[v._v("#")]),v._v(" 贪心算法特性")]),v._v(" "),t("p",[v._v("较于动态规划，贪心算法的使用条件更加苛刻，其主要关注问题的两个性质。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("贪心选择性质")]),v._v("：只有当局部最优选择始终可以导致全局最优解时，贪心算法才能保证得到最优解。")]),v._v(" "),t("li",[t("strong",[v._v("最优子结构")]),v._v("：原问题的最优解包含子问题的最优解。")])]),v._v(" "),t("h3",{attrs:{id:"贪心算法解题步骤"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法解题步骤"}},[v._v("#")]),v._v(" 贪心算法解题步骤")]),v._v(" "),t("p",[v._v("贪心问题的解决流程大体可分为以下三步。")]),v._v(" "),t("ol",[t("li",[t("strong",[v._v("问题分析")]),v._v("：梳理与理解问题特性，包括状态定义、优化目标和约束条件等。这一步在回溯和动态规划中都有涉及。")]),v._v(" "),t("li",[t("strong",[v._v("确定贪心策略")]),v._v("：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终解决整个问题。")]),v._v(" "),t("li",[t("strong",[v._v("正确性证明")]),v._v("：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要用到数学证明，例如归纳法或反证法等。")])]),v._v(" "),t("p",[v._v("确定贪心策略是求解问题的核心步骤，但实施起来可能并不容易，主要有以下原因。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("不同问题的贪心策略的差异较大")]),v._v("。对于许多问题来说，贪心策略比较浅显，我们通过一些大概的思考与尝试就能得出。而对于一些复杂问题，贪心策略可能非常隐蔽，这种情况就非常考验个人的解题经验与算法能力了。")]),v._v(" "),t("li",[t("strong",[v._v("某些贪心策略具有较强的迷惑性")]),v._v("。当我们满怀信心设计好贪心策略，写出解题代码并提交运行，很可能发现部分测试样例无法通过。这是因为设计的贪心策略只是“部分正确”的，上文介绍的零钱兑换就是一个典型案例。")])]),v._v(" "),t("h2",{attrs:{id:"贪心算法典型例题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#贪心算法典型例题"}},[v._v("#")]),v._v(" 贪心算法典型例题")]),v._v(" "),t("p",[v._v("贪心算法常常应用在满足贪心选择性质和最优子结构的优化问题中，以下列举了一些典型的贪心算法问题。")]),v._v(" "),t("ul",[t("li",[t("strong",[v._v("硬币找零问题")]),v._v("：在某些硬币组合下，贪心算法总是可以得到最优解。")]),v._v(" "),t("li",[t("strong",[v._v("区间调度问题")]),v._v("：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。")]),v._v(" "),t("li",[t("strong",[v._v("分数背包问题")]),v._v("：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解。")]),v._v(" "),t("li",[t("strong",[v._v("股票买卖问题")]),v._v("：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。")]),v._v(" "),t("li",[t("strong",[v._v("霍夫曼编码")]),v._v("：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度（编码长度）最小。")]),v._v(" "),t("li",[t("strong",[v._v("Dijkstra 算法")]),v._v("：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);